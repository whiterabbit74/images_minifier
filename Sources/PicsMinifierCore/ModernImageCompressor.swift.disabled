import Foundation
import UniformTypeIdentifiers
import CoreGraphics
import ImageIO

/// Современный компрессор изображений с использованием лучших алгоритмов
public final class ModernImageCompressor {
    public init() {}

    public func compressFile(at inputURL: URL, settings: AppSettings) -> ProcessResult {
        do {
            // Validate input file path for security
            let validatedInputPath = try SecurityUtils.validateFilePath(inputURL.path)
            let validatedInputURL = URL(fileURLWithPath: validatedInputPath)

            let fm = FileManager.default
            let originalSize = (try fm.attributesOfItem(atPath: validatedInputURL.path)[.size] as? NSNumber)?.int64Value ?? 0
            let resVals = try validatedInputURL.resourceValues(forKeys: [.contentTypeKey])
            let sourceType = resVals.contentType
            let sourceFormat = sourceType?.preferredFilenameExtension ?? validatedInputURL.pathExtension.lowercased()

            // Validate file size limits (prevent DoS attacks)
            let maxFileSize: Int64 = 500 * 1024 * 1024 // 500MB limit
            guard originalSize <= maxFileSize else {
                return ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: sourceFormat,
                    originalPath: validatedInputURL.path,
                    outputPath: validatedInputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: originalSize,
                    status: "skipped",
                    reason: "file-too-large"
                )
            }

            guard let utType = sourceType else {
                return ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: sourceFormat,
                    originalPath: validatedInputURL.path,
                    outputPath: validatedInputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: originalSize,
                    status: "skipped",
                    reason: "unknown-content-type"
                )
            }

            // Определяем выходной путь с валидацией
            let outputURL = try Self.computeSecureOutputURL(for: validatedInputURL, mode: settings.saveMode)

            let result: ProcessResult

            if utType.conforms(to: .jpeg) {
                result = try compressJPEGSecure(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else if utType.conforms(to: .png) {
                result = try compressPNGSecure(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else if utType.conforms(to: .gif) {
                result = compressGIF(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else if utType.conforms(to: UTType(importedAs: "org.webmproject.webp")) {
                result = compressWebP(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else {
                // Для других форматов используем системный кодек
                result = ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: sourceFormat,
                    originalPath: validatedInputURL.path,
                    outputPath: validatedInputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: originalSize,
                    status: "skipped",
                    reason: "format-not-supported-by-modern-compressor"
                )
            }

            return result

        } catch {
            return ProcessResult(
                sourceFormat: "unknown",
                targetFormat: "unknown",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: 0,
                newSizeBytes: 0,
                status: "skipped",
                reason: "security-validation-failed: \(error.localizedDescription)"
            )
        }
    }

    // MARK: - JPEG Compression

    private func compressJPEGSecure(inputURL: URL, outputURL: URL, settings: AppSettings) throws -> ProcessResult {
        let fm = FileManager.default
        let originalSize = (try? fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0
        let sourceFormat = "jpg"

        // Создаем временную копию
        let tempURL = fm.temporaryDirectory.appendingPathComponent(UUID().uuidString + ".jpg")
        do {
            try fm.copyItem(at: inputURL, to: tempURL)
        } catch {
            return ProcessResult(
                sourceFormat: sourceFormat,
                targetFormat: "jpg",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: originalSize,
                status: "skipped",
                reason: "copy-failed"
            )
        }

        // Определяем уровень сжатия на основе настроек
        let quality: Int
        switch settings.preset {
        case .quality: quality = 95
        case .balanced: quality = 85
        case .saving: quality = 75
        case .auto: quality = 85
        }

        // Используем jpegoptim для оптимального сжатия
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/opt/homebrew/bin/jpegoptim")

        var args = ["-m\(quality)", "--strip-all", "--all-progressive"]

        // Добавляем размерные ограничения если нужно
        if let maxDim = settings.maxDimension, maxDim > 0 {
            // Используем ImageMagick для изменения размера перед оптимизацией
            let resizeProcess = Process()
            resizeProcess.executableURL = URL(fileURLWithPath: "/opt/homebrew/bin/magick")
            resizeProcess.arguments = ["convert", tempURL.path, "-resize", "\(maxDim)x\(maxDim)>", tempURL.path]
            resizeProcess.standardOutput = Pipe()
            resizeProcess.standardError = Pipe()

            do {
                try resizeProcess.run()
                resizeProcess.waitUntilExit()
            } catch {
                // Игнорируем ошибку изменения размера
            }
        }

        args.append(tempURL.path)
        process.arguments = args
        process.standardOutput = Pipe()
        process.standardError = Pipe()

        do {
            try process.run()
            process.waitUntilExit()
        } catch {
            // Очистка временного файла
            try? fm.removeItem(at: tempURL)
            return ProcessResult(
                sourceFormat: sourceFormat,
                targetFormat: "jpg",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: originalSize,
                status: "skipped",
                reason: "jpegoptim-failed"
            )
        }

        if process.terminationStatus == 0 {
            // Определяем финальный путь
            let finalOutputURL = (settings.saveMode == .overwrite) ? inputURL : outputURL

            do {
                if fm.fileExists(atPath: finalOutputURL.path) {
                    try fm.removeItem(at: finalOutputURL)
                }
                try fm.moveItem(at: tempURL, to: finalOutputURL)

                let newSize = (try? fm.attributesOfItem(atPath: finalOutputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
                let saved = max(0, originalSize - newSize)

                return ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: "jpg",
                    originalPath: inputURL.path,
                    outputPath: finalOutputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: newSize,
                    status: "ok",
                    reason: saved > 0 ? "compressed-with-jpegoptim" : "no-gain"
                )
            } catch {
                try? fm.removeItem(at: tempURL)
                return ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: "jpg",
                    originalPath: inputURL.path,
                    outputPath: inputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: originalSize,
                    status: "skipped",
                    reason: "move-failed"
                )
            }
        } else {
            try? fm.removeItem(at: tempURL)
            return ProcessResult(
                sourceFormat: sourceFormat,
                targetFormat: "jpg",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: originalSize,
                status: "skipped",
                reason: "jpegoptim-nonzero-exit"
            )
        }
    }

    // MARK: - PNG Compression

    private func compressPNG(inputURL: URL, outputURL: URL, settings: AppSettings) -> ProcessResult {
        let fm = FileManager.default
        let originalSize = (try? fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0
        let sourceFormat = "png"

        // Создаем копию для обработки
        let tempURL = fm.temporaryDirectory.appendingPathComponent(UUID().uuidString + ".png")
        do {
            try fm.copyItem(at: inputURL, to: tempURL)
        } catch {
            return ProcessResult(
                sourceFormat: sourceFormat,
                targetFormat: "png",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: originalSize,
                status: "skipped",
                reason: "copy-failed"
            )
        }

        // Используем oxipng для лучшего PNG сжатия
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/opt/homebrew/bin/oxipng")

        var args = ["-o", "4", "--strip", "all"]

        // Добавляем размерные ограничения если нужно
        if let maxDim = settings.maxDimension, maxDim > 0 {
            args += ["--resize", "\(maxDim)x\(maxDim)"]
        }

        args.append(tempURL.path)
        process.arguments = args
        process.standardOutput = Pipe()
        process.standardError = Pipe()

        do {
            try process.run()
            process.waitUntilExit()
        } catch {
            // Очистка временного файла
            try? fm.removeItem(at: tempURL)
            return ProcessResult(
                sourceFormat: sourceFormat,
                targetFormat: "png",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: originalSize,
                status: "skipped",
                reason: "oxipng-failed"
            )
        }

        if process.terminationStatus == 0 {
            // Определяем финальный путь
            let finalOutputURL = (settings.saveMode == .overwrite) ? inputURL : outputURL

            do {
                if fm.fileExists(atPath: finalOutputURL.path) {
                    try fm.removeItem(at: finalOutputURL)
                }
                try fm.moveItem(at: tempURL, to: finalOutputURL)

                let newSize = (try? fm.attributesOfItem(atPath: finalOutputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
                let saved = max(0, originalSize - newSize)

                return ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: "png",
                    originalPath: inputURL.path,
                    outputPath: finalOutputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: newSize,
                    status: "ok",
                    reason: saved > 0 ? "compressed-with-oxipng" : "no-gain"
                )
            } catch {
                try? fm.removeItem(at: tempURL)
                return ProcessResult(
                    sourceFormat: sourceFormat,
                    targetFormat: "png",
                    originalPath: inputURL.path,
                    outputPath: inputURL.path,
                    originalSizeBytes: originalSize,
                    newSizeBytes: originalSize,
                    status: "skipped",
                    reason: "move-failed"
                )
            }
        } else {
            try? fm.removeItem(at: tempURL)
            return ProcessResult(
                sourceFormat: sourceFormat,
                targetFormat: "png",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: originalSize,
                status: "skipped",
                reason: "oxipng-nonzero-exit"
            )
        }
    }

    // MARK: - GIF Compression

    private func compressGIF(inputURL: URL, outputURL: URL, settings: AppSettings) -> ProcessResult {
        // Используем существующий GifsicleOptimizer
        let optimizer = GifsicleOptimizer()
        let out = (settings.saveMode == .overwrite) ? inputURL : outputURL
        return optimizer.optimize(inputURL: inputURL, outputURL: out)
    }

    // MARK: - WebP Compression

    private func compressWebP(inputURL: URL, outputURL: URL, settings: AppSettings) -> ProcessResult {
        // Используем существующий WebP encoder или CLI
        let encoder = WebPEncoder()
        switch encoder.availability() {
        case .systemCodec:
            return reencodeWebPWithSystem(inputURL: inputURL, outputURL: outputURL, settings: settings)
        case .embedded:
            return reencodeWebPWithEmbedded(inputURL: inputURL, outputURL: outputURL, settings: settings)
        case .unavailable:
            if ProcessInfo.processInfo.environment["PICS_FORCE_WEBP_CLI"] == "1" {
                let cli = WebPCliReencoder()
                let out = (settings.saveMode == .overwrite) ? inputURL : outputURL
                return cli.reencode(inputURL: inputURL, outputURL: out, quality: Int(webPQuality(for: settings.preset)), preserveMetadata: settings.preserveMetadata)
            }
            return ProcessResult(
                sourceFormat: "webp",
                targetFormat: "webp",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: (try? FileManager.default.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0,
                newSizeBytes: (try? FileManager.default.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0,
                status: "skipped",
                reason: "webp-encoder-unavailable"
            )
        }
    }

    private func reencodeWebPWithSystem(inputURL: URL, outputURL: URL, settings: AppSettings) -> ProcessResult {
        // Используем системный WebP кодек через ImageIO
        let fm = FileManager.default
        let originalSize = (try? fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0
        let sourceFormat = "webp"

        guard let src = CGImageSourceCreateWithURL(inputURL as CFURL, nil as CFDictionary?) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "cgimage-source-failed")
        }
        guard let baseImage = CGImageSourceCreateImageAtIndex(src, 0, nil as CFDictionary?) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "cgimage-create-failed")
        }

        let parentDir = outputURL.deletingLastPathComponent()
        try? fm.createDirectory(at: parentDir, withIntermediateDirectories: true)
        guard let dest = CGImageDestinationCreateWithURL(outputURL as CFURL, UTType(importedAs: "org.webmproject.webp").identifier as CFString, 1, nil as CFDictionary?) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "cgimage-dest-create-failed")
        }

        var props: [CFString: Any] = [:]
        props[kCGImageDestinationLossyCompressionQuality] = webPQuality(for: settings.preset) / 100.0

        CGImageDestinationAddImage(dest, baseImage, props as CFDictionary)
        guard CGImageDestinationFinalize(dest) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "cgimage-finalize-failed")
        }

        let newSize = (try? fm.attributesOfItem(atPath: outputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
        let saved = max(0, originalSize - newSize)
        return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: outputURL.path, originalSizeBytes: originalSize, newSizeBytes: newSize, status: "ok", reason: saved > 0 ? nil : "no-gain")
    }

    private func reencodeWebPWithEmbedded(inputURL: URL, outputURL: URL, settings: AppSettings) -> ProcessResult {
        // Используем встроенный WebP encoder
        let fm = FileManager.default
        let originalSize = (try? fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0
        let sourceFormat = "webp"

        guard let src = CGImageSourceCreateWithURL(inputURL as CFURL, nil as CFDictionary?) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "cgimage-source-failed")
        }
        guard let baseImage = CGImageSourceCreateImageAtIndex(src, 0, nil as CFDictionary?) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "cgimage-create-failed")
        }

        let srcW = baseImage.width
        let srcH = baseImage.height
        let (dstW, dstH) = scaledSize(width: srcW, height: srcH, maxDimension: settings.maxDimension)
        let colorSpace = CGColorSpace(name: CGColorSpace.sRGB) ?? baseImage.colorSpace ?? CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo.byteOrder32Little.union(CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedFirst.rawValue))

        guard let ctx = CGContext(data: nil, width: dstW, height: dstH, bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: bitmapInfo.rawValue, releaseCallback: nil, releaseInfo: nil) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "bitmap-context-failed")
        }

        ctx.interpolationQuality = CGInterpolationQuality.high
        ctx.draw(baseImage, in: CGRect(x: 0, y: 0, width: CGFloat(dstW), height: CGFloat(dstH)))

        guard let dataPtr = ctx.data else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "bitmap-data-missing")
        }

        let bytesPerRow = ctx.bytesPerRow
        let byteCount = bytesPerRow * dstH
        let rgbaData = Data(bytes: dataPtr, count: byteCount)
        let encoder = WebPEncoder()
        let q = Int(webPQuality(for: settings.preset))

        guard let webpData = encoder.encodeRGBA(rgbaData, width: dstW, height: dstH, quality: q) else {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "embedded-webp-encode-failed")
        }

        try? fm.createDirectory(at: outputURL.deletingLastPathComponent(), withIntermediateDirectories: true)
        do {
            try webpData.write(to: outputURL, options: .atomic)
        } catch {
            return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: inputURL.path, originalSizeBytes: originalSize, newSizeBytes: originalSize, status: "skipped", reason: "write-failed")
        }

        let newSize = (try? fm.attributesOfItem(atPath: outputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
        return ProcessResult(sourceFormat: sourceFormat, targetFormat: "webp", originalPath: inputURL.path, outputPath: outputURL.path, originalSizeBytes: originalSize, newSizeBytes: newSize, status: "ok", reason: newSize < originalSize ? nil : "no-gain")
    }

    private func webPQuality(for preset: CompressionPreset) -> Float {
        switch preset {
        case .quality: return 95.0
        case .balanced: return 85.0
        case .saving: return 75.0
        case .auto: return 85.0
        }
    }

    private func scaledSize(width: Int, height: Int, maxDimension: Int?) -> (Int, Int) {
        guard let maxDim = maxDimension, maxDim > 0 else { return (width, height) }
        let w = CGFloat(width)
        let h = CGFloat(height)
        let maxD = CGFloat(maxDim)
        let scale = min(1.0, maxD / max(w, h))
        let newW = Int((w * scale).rounded(.toNearestOrAwayFromZero))
        let newH = Int((h * scale).rounded(.toNearestOrAwayFromZero))
        return (max(newW, 1), max(newH, 1))
    }

    private static func computeOutputURL(for inputURL: URL, mode: SaveMode) -> URL {
        switch mode {
        case .suffix:
            let ext = inputURL.pathExtension
            let base = inputURL.deletingPathExtension().lastPathComponent
            let dir = inputURL.deletingLastPathComponent()
            return dir.appendingPathComponent("\(base)_modern").appendingPathExtension(ext)
        case .separateFolder:
            let dir = inputURL.deletingLastPathComponent()
            let outDir = dir.appendingPathComponent("ModernCompressed")
            let ext = inputURL.pathExtension
            let base = inputURL.deletingPathExtension().lastPathComponent
            return outDir.appendingPathComponent("\(base)").appendingPathExtension(ext)
        case .overwrite:
            return inputURL
        }
    }
}
