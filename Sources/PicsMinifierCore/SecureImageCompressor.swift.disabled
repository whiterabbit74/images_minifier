import Foundation
import UniformTypeIdentifiers
import CoreGraphics
import ImageIO

/// Secure modern image compressor with comprehensive security controls
public final class SecureImageCompressor {

    // Configuration constants
    private static let maxFileSize: Int64 = 500 * 1024 * 1024 // 500MB
    private static let maxConcurrentOperations = 4
    private static let processTimeout: TimeInterval = 120.0 // 2 minutes

    private let operationQueue: OperationQueue

    public init() {
        operationQueue = OperationQueue()
        operationQueue.maxConcurrentOperationCount = Self.maxConcurrentOperations
        operationQueue.qualityOfService = .userInitiated
    }

    public func compressFile(at inputURL: URL, settings: AppSettings) async -> ProcessResult {
        return await withCheckedContinuation { continuation in
            operationQueue.addOperation {
                let result = self.compressFileSync(at: inputURL, settings: settings)
                continuation.resume(returning: result)
            }
        }
    }

    private func compressFileSync(at inputURL: URL, settings: AppSettings) -> ProcessResult {
        do {
            // Security validation
            let validatedInputPath = try SecurityUtils.validateFilePath(inputURL.path)
            let validatedInputURL = URL(fileURLWithPath: validatedInputPath)

            // File validation
            try validateInputFile(validatedInputURL)

            let fm = FileManager.default
            let originalSize = (try fm.attributesOfItem(atPath: validatedInputURL.path)[.size] as? NSNumber)?.int64Value ?? 0
            let resVals = try validatedInputURL.resourceValues(forKeys: [.contentTypeKey])
            let sourceType = resVals.contentType
            let sourceFormat = sourceType?.preferredFilenameExtension ?? validatedInputURL.pathExtension.lowercased()

            guard let utType = sourceType else {
                throw SecureCompressionError.unknownFileType
            }

            // Secure output path computation
            let outputURL = try computeSecureOutputURL(for: validatedInputURL, mode: settings.saveMode)

            let result: ProcessResult

            if utType.conforms(to: .jpeg) {
                result = try compressJPEGSecure(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else if utType.conforms(to: .png) {
                result = try compressPNGSecure(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else if utType.conforms(to: .gif) {
                result = try compressGIFSecure(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else if utType.conforms(to: UTType(importedAs: "org.webmproject.webp")) {
                result = try compressWebPSecure(inputURL: validatedInputURL, outputURL: outputURL, settings: settings)
            } else {
                throw SecureCompressionError.unsupportedFormat(sourceFormat)
            }

            return result

        } catch {
            return ProcessResult(
                sourceFormat: "unknown",
                targetFormat: "unknown",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: 0,
                newSizeBytes: 0,
                status: "error",
                reason: error.localizedDescription
            )
        }
    }

    // MARK: - File Validation

    private func validateInputFile(_ url: URL) throws {
        let fm = FileManager.default

        // Check if file exists and is readable
        guard fm.fileExists(atPath: url.path), fm.isReadableFile(atPath: url.path) else {
            throw SecureCompressionError.fileNotAccessible
        }

        // Get file attributes
        let attributes = try fm.attributesOfItem(atPath: url.path)

        // Ensure it's a regular file
        guard let fileType = attributes[.type] as? FileAttributeType,
              fileType == .typeRegular else {
            throw SecureCompressionError.notRegularFile
        }

        // Check file size
        guard let fileSize = attributes[.size] as? NSNumber,
              fileSize.int64Value <= Self.maxFileSize else {
            throw SecureCompressionError.fileTooLarge
        }

        // Additional security checks for symlinks
        let resolvedURL = url.resolvingSymlinksInPath()
        if resolvedURL.path != url.path {
            // This is a symlink - validate the target
            _ = try SecurityUtils.validateFilePath(resolvedURL.path)
        }
    }

    // MARK: - Secure Tool Location

    private func locateSecureTool(_ toolName: String) throws -> URL {
        let fm = FileManager.default

        // Predefined secure paths
        let securePaths = [
            "/opt/homebrew/bin/\(toolName)",
            "/usr/local/bin/\(toolName)",
            "/usr/bin/\(toolName)"
        ]

        for path in securePaths {
            let url = URL(fileURLWithPath: path)
            do {
                if try validateExecutable(url) {
                    return url
                }
            } catch {
                continue
            }
        }

        throw SecureCompressionError.toolNotFound(toolName)
    }

    private func validateExecutable(_ url: URL) throws -> Bool {
        let fm = FileManager.default

        guard fm.fileExists(atPath: url.path) else {
            return false
        }

        // Validate path security
        _ = try SecurityUtils.validateFilePath(url.path)

        // Check file type and permissions
        let attributes = try fm.attributesOfItem(atPath: url.path)
        guard let fileType = attributes[.type] as? FileAttributeType,
              fileType == .typeRegular else {
            throw SecureCompressionError.invalidExecutable
        }

        return fm.isExecutableFile(atPath: url.path)
    }

    // MARK: - Secure Compression Methods

    private func compressJPEGSecure(inputURL: URL, outputURL: URL, settings: AppSettings) throws -> ProcessResult {
        let fm = FileManager.default
        let originalSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0

        // Locate jpegoptim securely
        let jpegoptim = try locateSecureTool("jpegoptim")

        // Create secure temporary directory
        let tempDir = try SecurityUtils.createSecureTempDirectory()
        defer {
            try? fm.removeItem(at: tempDir)
        }

        let tempFile = tempDir.appendingPathComponent("temp.jpg")
        try SecurityUtils.secureCopy(from: inputURL, to: tempFile)

        // Validate quality settings
        let quality = max(1, min(100, qualityForPreset(settings.preset)))

        // Build secure arguments
        var args = ["-m\(quality)", "--strip-all", "--all-progressive"]

        // Handle max dimension securely
        if let maxDim = settings.maxDimension, maxDim > 0 && maxDim <= 10000 {
            // Use ImageMagick for resizing if available
            if let magick = try? locateSecureTool("magick") {
                let resizeArgs = ["convert", tempFile.path, "-resize", "\(maxDim)x\(maxDim)>", tempFile.path]
                let _ = try SecurityUtils.executeSecureProcess(
                    executable: magick,
                    arguments: resizeArgs,
                    timeout: Self.processTimeout
                )
            }
        }

        args.append(tempFile.path)

        // Execute jpegoptim securely
        let result = try SecurityUtils.executeSecureProcess(
            executable: jpegoptim,
            arguments: args,
            timeout: Self.processTimeout
        )

        guard result.isSuccess else {
            throw SecureCompressionError.compressionFailed("jpegoptim: \(result.stderr)")
        }

        // Atomic move to final destination
        try fm.createDirectory(at: outputURL.deletingLastPathComponent(), withIntermediateDirectories: true)

        if settings.saveMode == .overwrite {
            try SecurityUtils.atomicWrite(data: Data(contentsOf: tempFile), to: inputURL)
            let newSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "jpg",
                targetFormat: "jpg",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        } else {
            try SecurityUtils.secureCopy(from: tempFile, to: outputURL)
            let newSize = (try fm.attributesOfItem(atPath: outputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "jpg",
                targetFormat: "jpg",
                originalPath: inputURL.path,
                outputPath: outputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        }
    }

    private func compressPNGSecure(inputURL: URL, outputURL: URL, settings: AppSettings) throws -> ProcessResult {
        let fm = FileManager.default
        let originalSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0

        // Locate oxipng securely
        let oxipng = try locateSecureTool("oxipng")

        // Create secure temporary directory
        let tempDir = try SecurityUtils.createSecureTempDirectory()
        defer {
            try? fm.removeItem(at: tempDir)
        }

        let tempFile = tempDir.appendingPathComponent("temp.png")
        try SecurityUtils.secureCopy(from: inputURL, to: tempFile)

        // Build secure arguments
        var args = ["-o", "4", "--strip", "all"]

        // Handle max dimension securely
        if let maxDim = settings.maxDimension, maxDim > 0 && maxDim <= 10000 {
            args += ["--resize", "\(maxDim)x\(maxDim)"]
        }

        args.append(tempFile.path)

        // Execute oxipng securely
        let result = try SecurityUtils.executeSecureProcess(
            executable: oxipng,
            arguments: args,
            timeout: Self.processTimeout
        )

        guard result.isSuccess else {
            throw SecureCompressionError.compressionFailed("oxipng: \(result.stderr)")
        }

        // Handle output based on save mode
        if settings.saveMode == .overwrite {
            try SecurityUtils.atomicWrite(data: Data(contentsOf: tempFile), to: inputURL)
            let newSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "png",
                targetFormat: "png",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        } else {
            try SecurityUtils.secureCopy(from: tempFile, to: outputURL)
            let newSize = (try fm.attributesOfItem(atPath: outputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "png",
                targetFormat: "png",
                originalPath: inputURL.path,
                outputPath: outputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        }
    }

    private func compressGIFSecure(inputURL: URL, outputURL: URL, settings: AppSettings) throws -> ProcessResult {
        // Use secure version of GifsicleOptimizer
        let optimizer = SecureGifsicleOptimizer()
        return try optimizer.optimizeSecure(inputURL: inputURL, outputURL: outputURL, settings: settings)
    }

    private func compressWebPSecure(inputURL: URL, outputURL: URL, settings: AppSettings) throws -> ProcessResult {
        // Use secure WebP reencoder
        let reencoder = SecureWebPReencoder()
        return try reencoder.reencodeSecure(
            inputURL: inputURL,
            outputURL: outputURL,
            quality: qualityForPreset(settings.preset),
            preserveMetadata: settings.preserveMetadata
        )
    }

    // MARK: - Utilities

    private func qualityForPreset(_ preset: CompressionPreset) -> Int {
        switch preset {
        case .quality: return 95
        case .balanced: return 85
        case .saving: return 75
        case .auto: return 85
        }
    }

    private func computeSecureOutputURL(for inputURL: URL, mode: SaveMode) throws -> URL {
        let outputURL: URL

        switch mode {
        case .suffix:
            let ext = inputURL.pathExtension
            let base = inputURL.deletingPathExtension().lastPathComponent
            let dir = inputURL.deletingLastPathComponent()
            outputURL = dir.appendingPathComponent("\(base)_compressed").appendingPathExtension(ext)

        case .separateFolder:
            let dir = inputURL.deletingLastPathComponent()
            let outDir = dir.appendingPathComponent("Compressed")
            let ext = inputURL.pathExtension
            let base = inputURL.deletingPathExtension().lastPathComponent
            outputURL = outDir.appendingPathComponent(base).appendingPathExtension(ext)

        case .overwrite:
            outputURL = inputURL
        }

        // Validate output path
        _ = try SecurityUtils.validateFilePath(outputURL.path)

        return outputURL
    }
}

// MARK: - Error Types

public enum SecureCompressionError: Error, LocalizedError {
    case unknownFileType
    case unsupportedFormat(String)
    case fileNotAccessible
    case notRegularFile
    case fileTooLarge
    case toolNotFound(String)
    case invalidExecutable
    case compressionFailed(String)

    var errorDescription: String? {
        switch self {
        case .unknownFileType:
            return "Unknown file type"
        case .unsupportedFormat(let format):
            return "Unsupported format: \(format)"
        case .fileNotAccessible:
            return "File is not accessible"
        case .notRegularFile:
            return "Not a regular file"
        case .fileTooLarge:
            return "File is too large"
        case .toolNotFound(let tool):
            return "Compression tool not found: \(tool)"
        case .invalidExecutable:
            return "Invalid executable"
        case .compressionFailed(let details):
            return "Compression failed: \(details)"
        }
    }
}

// MARK: - Secure Helper Classes

class SecureGifsicleOptimizer {
    func optimizeSecure(inputURL: URL, outputURL: URL, settings: AppSettings) throws -> ProcessResult {
        let fm = FileManager.default
        let originalSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0

        let gifsicle = try locateSecureTool("gifsicle")

        let tempDir = try SecurityUtils.createSecureTempDirectory()
        defer {
            try? fm.removeItem(at: tempDir)
        }

        let tempFile = tempDir.appendingPathComponent("temp.gif")
        try SecurityUtils.secureCopy(from: inputURL, to: tempFile)

        let args = ["--optimize=3", tempFile.path, "-o", tempFile.path]

        let result = try SecurityUtils.executeSecureProcess(
            executable: gifsicle,
            arguments: args,
            timeout: 120.0
        )

        guard result.isSuccess else {
            throw SecureCompressionError.compressionFailed("gifsicle: \(result.stderr)")
        }

        if settings.saveMode == .overwrite {
            try SecurityUtils.atomicWrite(data: Data(contentsOf: tempFile), to: inputURL)
            let newSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "gif",
                targetFormat: "gif",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        } else {
            try SecurityUtils.secureCopy(from: tempFile, to: outputURL)
            let newSize = (try fm.attributesOfItem(atPath: outputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "gif",
                targetFormat: "gif",
                originalPath: inputURL.path,
                outputPath: outputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        }
    }

    private func locateSecureTool(_ toolName: String) throws -> URL {
        let securePaths = [
            "/opt/homebrew/bin/\(toolName)",
            "/usr/local/bin/\(toolName)",
            "/usr/bin/\(toolName)"
        ]

        for path in securePaths {
            let url = URL(fileURLWithPath: path)
            if FileManager.default.isExecutableFile(atPath: url.path) {
                _ = try SecurityUtils.validateFilePath(url.path)
                return url
            }
        }

        throw SecureCompressionError.toolNotFound(toolName)
    }
}

class SecureWebPReencoder {
    func reencodeSecure(inputURL: URL, outputURL: URL, quality: Int, preserveMetadata: Bool) throws -> ProcessResult {
        let fm = FileManager.default
        let originalSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? 0

        let cwebp = try locateSecureTool("cwebp")

        let tempDir = try SecurityUtils.createSecureTempDirectory()
        defer {
            try? fm.removeItem(at: tempDir)
        }

        let tempFile = tempDir.appendingPathComponent("temp.webp")

        let qualityStr = String(max(0, min(100, quality)))
        var args = [inputURL.path, "-q", qualityStr, "-quiet"]

        if preserveMetadata {
            args += ["-metadata", "all"]
        } else {
            args += ["-metadata", "none"]
        }

        args += ["-o", tempFile.path]

        let result = try SecurityUtils.executeSecureProcess(
            executable: cwebp,
            arguments: args,
            timeout: 120.0
        )

        guard result.isSuccess, fm.fileExists(atPath: tempFile.path) else {
            throw SecureCompressionError.compressionFailed("cwebp: \(result.stderr)")
        }

        if outputURL == inputURL { // overwrite mode
            try SecurityUtils.atomicWrite(data: Data(contentsOf: tempFile), to: inputURL)
            let newSize = (try fm.attributesOfItem(atPath: inputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "webp",
                targetFormat: "webp",
                originalPath: inputURL.path,
                outputPath: inputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        } else {
            try SecurityUtils.secureCopy(from: tempFile, to: outputURL)
            let newSize = (try fm.attributesOfItem(atPath: outputURL.path)[.size] as? NSNumber)?.int64Value ?? originalSize
            return ProcessResult(
                sourceFormat: "webp",
                targetFormat: "webp",
                originalPath: inputURL.path,
                outputPath: outputURL.path,
                originalSizeBytes: originalSize,
                newSizeBytes: newSize,
                status: "ok"
            )
        }
    }

    private func locateSecureTool(_ toolName: String) throws -> URL {
        let securePaths = [
            "/opt/homebrew/bin/\(toolName)",
            "/usr/local/bin/\(toolName)",
            "/usr/bin/\(toolName)"
        ]

        for path in securePaths {
            let url = URL(fileURLWithPath: path)
            if FileManager.default.isExecutableFile(atPath: url.path) {
                _ = try SecurityUtils.validateFilePath(url.path)
                return url
            }
        }

        throw SecureCompressionError.toolNotFound(toolName)
    }
}